### This file was generated by Nexus Schema
### Do not make changes to this file directly


type budget {
  id: Int!
  stacks(after: stacksWhereUniqueInput, before: stacksWhereUniqueInput, first: Int, last: Int): [stacks!]!
  toBeBudgeted: Float
  total: Float
  userId: Int
}

input budgetCreateManyWithoutUserInput {
  connect: [budgetWhereUniqueInput]
  create: [budgetCreateWithoutUserInput]
}

input budgetCreateOneWithoutStacksInput {
  connect: budgetWhereUniqueInput
  create: budgetCreateWithoutStacksInput
}

input budgetCreateWithoutStacksInput {
  toBeBudgeted: Float
  total: Float
  user: userCreateOneWithoutBudgetInput
}

input budgetCreateWithoutUserInput {
  stacks: stacksCreateManyWithoutBudgetInput
  toBeBudgeted: Float
  total: Float
}

input BudgetId_label_idxCompoundUniqueInput {
  budgetId: Int!
  label: String!
}

input budgetScalarWhereInput {
  AND: [budgetScalarWhereInput]
  id: IntFilter
  NOT: [budgetScalarWhereInput]
  OR: [budgetScalarWhereInput]
  toBeBudgeted: FloatNullableFilter
  total: FloatNullableFilter
  userId: IntNullableFilter
}

input budgetUpdateInput {
  stacks: stacksUpdateManyWithoutBudgetInput
  toBeBudgeted: NullableFloatFieldUpdateOperationsInput
  total: NullableFloatFieldUpdateOperationsInput
  user: userUpdateOneWithoutBudgetInput
}

input budgetUpdateManyDataInput {
  toBeBudgeted: NullableFloatFieldUpdateOperationsInput
  total: NullableFloatFieldUpdateOperationsInput
}

input budgetUpdateManyWithoutUserInput {
  connect: [budgetWhereUniqueInput]
  create: [budgetCreateWithoutUserInput]
  delete: [budgetWhereUniqueInput]
  deleteMany: [budgetScalarWhereInput]
  disconnect: [budgetWhereUniqueInput]
  set: [budgetWhereUniqueInput]
  update: [budgetUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [budgetUpdateManyWithWhereNestedInput]
  upsert: [budgetUpsertWithWhereUniqueWithoutUserInput]
}

input budgetUpdateManyWithWhereNestedInput {
  data: budgetUpdateManyDataInput!
  where: budgetScalarWhereInput!
}

input budgetUpdateOneRequiredWithoutStacksInput {
  connect: budgetWhereUniqueInput
  create: budgetCreateWithoutStacksInput
  update: budgetUpdateWithoutStacksDataInput
  upsert: budgetUpsertWithoutStacksInput
}

input budgetUpdateWithoutStacksDataInput {
  toBeBudgeted: NullableFloatFieldUpdateOperationsInput
  total: NullableFloatFieldUpdateOperationsInput
  user: userUpdateOneWithoutBudgetInput
}

input budgetUpdateWithoutUserDataInput {
  stacks: stacksUpdateManyWithoutBudgetInput
  toBeBudgeted: NullableFloatFieldUpdateOperationsInput
  total: NullableFloatFieldUpdateOperationsInput
}

input budgetUpdateWithWhereUniqueWithoutUserInput {
  data: budgetUpdateWithoutUserDataInput!
  where: budgetWhereUniqueInput!
}

input budgetUpsertWithoutStacksInput {
  create: budgetCreateWithoutStacksInput!
  update: budgetUpdateWithoutStacksDataInput!
}

input budgetUpsertWithWhereUniqueWithoutUserInput {
  create: budgetCreateWithoutUserInput!
  update: budgetUpdateWithoutUserDataInput!
  where: budgetWhereUniqueInput!
}

input budgetWhereUniqueInput {
  id: Int
}

scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input FloatFieldUpdateOperationsInput {
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

type Mutation {
  createOnestacks(data: stacksCreateInput!): stacks!
  createOnetransactions(data: transactionsCreateInput!): transactions!
  updateOnebudget(data: budgetUpdateInput!, where: budgetWhereUniqueInput!): budget
  updateOnestacks(data: stacksUpdateInput!, where: stacksWhereUniqueInput!): stacks
  updateOnetransactions(data: transactionsUpdateInput!, where: transactionsWhereUniqueInput!): transactions
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableFloatFieldUpdateOperationsInput {
  set: Float
}

type Query {
  budget(where: budgetWhereUniqueInput!): budget
  budgets(after: budgetWhereUniqueInput, before: budgetWhereUniqueInput, first: Int, last: Int): [budget!]!
  stacks(after: stacksWhereUniqueInput, before: stacksWhereUniqueInput, first: Int, last: Int): [stacks!]!
  transactions(after: transactionsWhereUniqueInput, before: transactionsWhereUniqueInput, first: Int, last: Int): [transactions!]!
}

type stacks {
  amount: Float!
  budgetId: Int!
  created_at: DateTime!
  id: Int!
  label: String!
}

input stacksCreateInput {
  amount: Float
  budget: budgetCreateOneWithoutStacksInput!
  created_at: DateTime
  label: String!
}

input stacksCreateManyWithoutBudgetInput {
  connect: [stacksWhereUniqueInput]
  create: [stacksCreateWithoutBudgetInput]
}

input stacksCreateWithoutBudgetInput {
  amount: Float
  created_at: DateTime
  label: String!
}

input stacksScalarWhereInput {
  amount: FloatFilter
  AND: [stacksScalarWhereInput]
  budgetId: IntFilter
  created_at: DateTimeFilter
  id: IntFilter
  label: StringFilter
  NOT: [stacksScalarWhereInput]
  OR: [stacksScalarWhereInput]
}

input stacksUpdateInput {
  amount: FloatFieldUpdateOperationsInput
  budget: budgetUpdateOneRequiredWithoutStacksInput
  created_at: DateTimeFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
}

input stacksUpdateManyDataInput {
  amount: FloatFieldUpdateOperationsInput
  created_at: DateTimeFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
}

input stacksUpdateManyWithoutBudgetInput {
  connect: [stacksWhereUniqueInput]
  create: [stacksCreateWithoutBudgetInput]
  delete: [stacksWhereUniqueInput]
  deleteMany: [stacksScalarWhereInput]
  disconnect: [stacksWhereUniqueInput]
  set: [stacksWhereUniqueInput]
  update: [stacksUpdateWithWhereUniqueWithoutBudgetInput]
  updateMany: [stacksUpdateManyWithWhereNestedInput]
  upsert: [stacksUpsertWithWhereUniqueWithoutBudgetInput]
}

input stacksUpdateManyWithWhereNestedInput {
  data: stacksUpdateManyDataInput!
  where: stacksScalarWhereInput!
}

input stacksUpdateWithoutBudgetDataInput {
  amount: FloatFieldUpdateOperationsInput
  created_at: DateTimeFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
}

input stacksUpdateWithWhereUniqueWithoutBudgetInput {
  data: stacksUpdateWithoutBudgetDataInput!
  where: stacksWhereUniqueInput!
}

input stacksUpsertWithWhereUniqueWithoutBudgetInput {
  create: stacksCreateWithoutBudgetInput!
  update: stacksUpdateWithoutBudgetDataInput!
  where: stacksWhereUniqueInput!
}

input stacksWhereUniqueInput {
  budgetId_label_idx: BudgetId_label_idxCompoundUniqueInput
  id: Int
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

type transactions {
  amount: Float!
  date: DateTime!
  description: String!
  id: Int!
  stack: String!
  type: String!
  userId: Int!
}

input transactionsCreateInput {
  amount: Float!
  date: DateTime!
  description: String!
  stack: String!
  type: String!
  user: userCreateOneWithoutTransactionsInput!
}

input transactionsCreateManyWithoutUserInput {
  connect: [transactionsWhereUniqueInput]
  create: [transactionsCreateWithoutUserInput]
}

input transactionsCreateWithoutUserInput {
  amount: Float!
  date: DateTime!
  description: String!
  stack: String!
  type: String!
}

input transactionsScalarWhereInput {
  amount: FloatFilter
  AND: [transactionsScalarWhereInput]
  date: DateTimeFilter
  description: StringFilter
  id: IntFilter
  NOT: [transactionsScalarWhereInput]
  OR: [transactionsScalarWhereInput]
  stack: StringFilter
  type: StringFilter
  userId: IntFilter
}

input transactionsUpdateInput {
  amount: FloatFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  stack: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  user: userUpdateOneRequiredWithoutTransactionsInput
}

input transactionsUpdateManyDataInput {
  amount: FloatFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  stack: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input transactionsUpdateManyWithoutUserInput {
  connect: [transactionsWhereUniqueInput]
  create: [transactionsCreateWithoutUserInput]
  delete: [transactionsWhereUniqueInput]
  deleteMany: [transactionsScalarWhereInput]
  disconnect: [transactionsWhereUniqueInput]
  set: [transactionsWhereUniqueInput]
  update: [transactionsUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [transactionsUpdateManyWithWhereNestedInput]
  upsert: [transactionsUpsertWithWhereUniqueWithoutUserInput]
}

input transactionsUpdateManyWithWhereNestedInput {
  data: transactionsUpdateManyDataInput!
  where: transactionsScalarWhereInput!
}

input transactionsUpdateWithoutUserDataInput {
  amount: FloatFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  stack: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input transactionsUpdateWithWhereUniqueWithoutUserInput {
  data: transactionsUpdateWithoutUserDataInput!
  where: transactionsWhereUniqueInput!
}

input transactionsUpsertWithWhereUniqueWithoutUserInput {
  create: transactionsCreateWithoutUserInput!
  update: transactionsUpdateWithoutUserDataInput!
  where: transactionsWhereUniqueInput!
}

input transactionsWhereUniqueInput {
  id: Int
}

type user {
  budget(after: budgetWhereUniqueInput, before: budgetWhereUniqueInput, first: Int, last: Int): [budget!]!
  created_at: DateTime
  email: String!
  id: Int!
  transactions(after: transactionsWhereUniqueInput, before: transactionsWhereUniqueInput, first: Int, last: Int): [transactions!]!
}

input userCreateOneWithoutBudgetInput {
  connect: userWhereUniqueInput
  create: userCreateWithoutBudgetInput
}

input userCreateOneWithoutTransactionsInput {
  connect: userWhereUniqueInput
  create: userCreateWithoutTransactionsInput
}

input userCreateWithoutBudgetInput {
  created_at: DateTime
  email: String!
  password: String!
  transactions: transactionsCreateManyWithoutUserInput
}

input userCreateWithoutTransactionsInput {
  budget: budgetCreateManyWithoutUserInput
  created_at: DateTime
  email: String!
  password: String!
}

input userUpdateOneRequiredWithoutTransactionsInput {
  connect: userWhereUniqueInput
  create: userCreateWithoutTransactionsInput
  update: userUpdateWithoutTransactionsDataInput
  upsert: userUpsertWithoutTransactionsInput
}

input userUpdateOneWithoutBudgetInput {
  connect: userWhereUniqueInput
  create: userCreateWithoutBudgetInput
  delete: Boolean
  disconnect: Boolean
  update: userUpdateWithoutBudgetDataInput
  upsert: userUpsertWithoutBudgetInput
}

input userUpdateWithoutBudgetDataInput {
  created_at: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  transactions: transactionsUpdateManyWithoutUserInput
}

input userUpdateWithoutTransactionsDataInput {
  budget: budgetUpdateManyWithoutUserInput
  created_at: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
}

input userUpsertWithoutBudgetInput {
  create: userCreateWithoutBudgetInput!
  update: userUpdateWithoutBudgetDataInput!
}

input userUpsertWithoutTransactionsInput {
  create: userCreateWithoutTransactionsInput!
  update: userUpdateWithoutTransactionsDataInput!
}

input userWhereUniqueInput {
  email: String
  id: Int
}
