### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

type budget {
  id: Int!
  stacks(after: stacksWhereUniqueInput, before: stacksWhereUniqueInput, first: Int, last: Int): [stacks!]!
  toBeBudgeted: Float
  total: Float
  userId: Int!
}

input budgetCreateInput {
  stacks: stacksCreateManyWithoutBudgetInput
  toBeBudgeted: Float
  total: Float
  user: userCreateOneWithoutBudgetInput!
}

input budgetCreateOneWithoutStacksInput {
  connect: budgetWhereUniqueInput
  connectOrCreate: budgetCreateOrConnectWithoutstacksInput
  create: budgetCreateWithoutStacksInput
}

input budgetCreateOneWithoutUserInput {
  connect: budgetWhereUniqueInput
  connectOrCreate: budgetCreateOrConnectWithoutuserInput
  create: budgetCreateWithoutUserInput
}

input budgetCreateOrConnectWithoutstacksInput {
  create: budgetCreateWithoutStacksInput!
  where: budgetWhereUniqueInput!
}

input budgetCreateOrConnectWithoutuserInput {
  create: budgetCreateWithoutUserInput!
  where: budgetWhereUniqueInput!
}

input budgetCreateWithoutStacksInput {
  toBeBudgeted: Float
  total: Float
  user: userCreateOneWithoutBudgetInput!
}

input budgetCreateWithoutUserInput {
  stacks: stacksCreateManyWithoutBudgetInput
  toBeBudgeted: Float
  total: Float
}

input BudgetId_label_idxCompoundUniqueInput {
  budgetId: Int!
  label: String!
}

input budgetUpdateInput {
  stacks: stacksUpdateManyWithoutBudgetInput
  toBeBudgeted: NullableFloatFieldUpdateOperationsInput
  total: NullableFloatFieldUpdateOperationsInput
  user: userUpdateOneRequiredWithoutBudgetInput
}

input budgetUpdateOneRequiredWithoutStacksInput {
  connect: budgetWhereUniqueInput
  connectOrCreate: budgetCreateOrConnectWithoutstacksInput
  create: budgetCreateWithoutStacksInput
  update: budgetUpdateWithoutStacksInput
  upsert: budgetUpsertWithoutStacksInput
}

input budgetUpdateOneRequiredWithoutUserInput {
  connect: budgetWhereUniqueInput
  connectOrCreate: budgetCreateOrConnectWithoutuserInput
  create: budgetCreateWithoutUserInput
  update: budgetUpdateWithoutUserInput
  upsert: budgetUpsertWithoutUserInput
}

input budgetUpdateWithoutStacksInput {
  toBeBudgeted: NullableFloatFieldUpdateOperationsInput
  total: NullableFloatFieldUpdateOperationsInput
  user: userUpdateOneRequiredWithoutBudgetInput
}

input budgetUpdateWithoutUserInput {
  stacks: stacksUpdateManyWithoutBudgetInput
  toBeBudgeted: NullableFloatFieldUpdateOperationsInput
  total: NullableFloatFieldUpdateOperationsInput
}

input budgetUpsertWithoutStacksInput {
  create: budgetCreateWithoutStacksInput!
  update: budgetUpdateWithoutStacksInput!
}

input budgetUpsertWithoutUserInput {
  create: budgetCreateWithoutUserInput!
  update: budgetUpdateWithoutUserInput!
}

input budgetWhereInput {
  AND: [budgetWhereInput!]
  id: IntFilter
  NOT: [budgetWhereInput!]
  OR: [budgetWhereInput!]
  stacks: StacksListRelationFilter
  toBeBudgeted: FloatNullableFilter
  total: FloatNullableFilter
  user: userWhereInput
  userId: IntFilter
}

input budgetWhereUniqueInput {
  id: Int
}

scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Mutation {
  createOnebudget(data: budgetCreateInput!): budget!
  createOnestacks(data: stacksCreateInput!): stacks!
  createOnetransactions(data: transactionsCreateInput!): transactions!
  createOneuser(data: userCreateInput!): user!
  deleteManytransactions(where: transactionsWhereInput): BatchPayload!
  updateOnebudget(data: budgetUpdateInput!, where: budgetWhereUniqueInput!): budget
  updateOnestacks(data: stacksUpdateInput!, where: stacksWhereUniqueInput!): stacks
  updateOnetransactions(data: transactionsUpdateInput!, where: transactionsWhereUniqueInput!): transactions
  uploadFile(file: Upload): UploadFile
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableFloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  budget(where: budgetWhereUniqueInput!): budget
  budgets(after: budgetWhereUniqueInput, before: budgetWhereUniqueInput, first: Int, last: Int, where: QueryBudgetsWhereInput): [budget!]!
  stacks(after: stacksWhereUniqueInput, before: stacksWhereUniqueInput, first: Int, last: Int): [stacks!]!
  transactions(after: transactionsWhereUniqueInput, before: transactionsWhereUniqueInput, first: Int, last: Int, orderBy: [QueryTransactionsOrderByInput!], where: QueryTransactionsWhereInput): [transactions!]!
  user(where: userWhereUniqueInput!): user
}

input QueryBudgetsWhereInput {
  user: userWhereInput
  userId: IntFilter
}

enum QueryMode {
  default
  insensitive
}

input QueryTransactionsOrderByInput {
  date: SortOrder
}

input QueryTransactionsWhereInput {
  user: userWhereInput
  userId: IntFilter
}

enum SortOrder {
  asc
  desc
}

type stacks {
  amount: Float!
  budgetId: Int!
  created_at: DateTime!
  id: Int!
  label: String!
}

input stacksCreateInput {
  amount: Float
  budget: budgetCreateOneWithoutStacksInput!
  created_at: DateTime
  label: String!
}

input stacksCreateManyWithoutBudgetInput {
  connect: [stacksWhereUniqueInput!]
  connectOrCreate: [stacksCreateOrConnectWithoutbudgetInput!]
  create: [stacksCreateWithoutBudgetInput!]
}

input stacksCreateOrConnectWithoutbudgetInput {
  create: stacksCreateWithoutBudgetInput!
  where: stacksWhereUniqueInput!
}

input stacksCreateWithoutBudgetInput {
  amount: Float
  created_at: DateTime
  label: String!
}

input StacksListRelationFilter {
  every: stacksWhereInput
  none: stacksWhereInput
  some: stacksWhereInput
}

input stacksScalarWhereInput {
  amount: FloatFilter
  AND: [stacksScalarWhereInput!]
  budgetId: IntFilter
  created_at: DateTimeFilter
  id: IntFilter
  label: StringFilter
  NOT: [stacksScalarWhereInput!]
  OR: [stacksScalarWhereInput!]
}

input stacksUpdateInput {
  amount: FloatFieldUpdateOperationsInput
  budget: budgetUpdateOneRequiredWithoutStacksInput
  created_at: DateTimeFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
}

input stacksUpdateManyMutationInput {
  amount: FloatFieldUpdateOperationsInput
  created_at: DateTimeFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
}

input stacksUpdateManyWithoutBudgetInput {
  connect: [stacksWhereUniqueInput!]
  connectOrCreate: [stacksCreateOrConnectWithoutbudgetInput!]
  create: [stacksCreateWithoutBudgetInput!]
  delete: [stacksWhereUniqueInput!]
  deleteMany: [stacksScalarWhereInput!]
  disconnect: [stacksWhereUniqueInput!]
  set: [stacksWhereUniqueInput!]
  update: [stacksUpdateWithWhereUniqueWithoutBudgetInput!]
  updateMany: [stacksUpdateManyWithWhereWithoutBudgetInput!]
  upsert: [stacksUpsertWithWhereUniqueWithoutBudgetInput!]
}

input stacksUpdateManyWithWhereWithoutBudgetInput {
  data: stacksUpdateManyMutationInput!
  where: stacksScalarWhereInput!
}

input stacksUpdateWithoutBudgetInput {
  amount: FloatFieldUpdateOperationsInput
  created_at: DateTimeFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
}

input stacksUpdateWithWhereUniqueWithoutBudgetInput {
  data: stacksUpdateWithoutBudgetInput!
  where: stacksWhereUniqueInput!
}

input stacksUpsertWithWhereUniqueWithoutBudgetInput {
  create: stacksCreateWithoutBudgetInput!
  update: stacksUpdateWithoutBudgetInput!
  where: stacksWhereUniqueInput!
}

input stacksWhereInput {
  amount: FloatFilter
  AND: [stacksWhereInput!]
  budget: budgetWhereInput
  budgetId: IntFilter
  created_at: DateTimeFilter
  id: IntFilter
  label: StringFilter
  NOT: [stacksWhereInput!]
  OR: [stacksWhereInput!]
}

input stacksWhereUniqueInput {
  budgetId_label_idx: BudgetId_label_idxCompoundUniqueInput
  id: Int
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type transactions {
  amount: Float!
  date: DateTime!
  description: String!
  id: Int!
  stack: String!
  type: String!
  userId: Int!
}

input transactionsCreateInput {
  amount: Float!
  date: DateTime!
  description: String!
  stack: String!
  type: String!
  user: userCreateOneWithoutTransactionsInput!
}

input transactionsCreateManyWithoutUserInput {
  connect: [transactionsWhereUniqueInput!]
  connectOrCreate: [transactionsCreateOrConnectWithoutuserInput!]
  create: [transactionsCreateWithoutUserInput!]
}

input transactionsCreateOrConnectWithoutuserInput {
  create: transactionsCreateWithoutUserInput!
  where: transactionsWhereUniqueInput!
}

input transactionsCreateWithoutUserInput {
  amount: Float!
  date: DateTime!
  description: String!
  stack: String!
  type: String!
}

input TransactionsListRelationFilter {
  every: transactionsWhereInput
  none: transactionsWhereInput
  some: transactionsWhereInput
}

input transactionsScalarWhereInput {
  amount: FloatFilter
  AND: [transactionsScalarWhereInput!]
  date: DateTimeFilter
  description: StringFilter
  id: IntFilter
  NOT: [transactionsScalarWhereInput!]
  OR: [transactionsScalarWhereInput!]
  stack: StringFilter
  type: StringFilter
  userId: IntFilter
}

input transactionsUpdateInput {
  amount: FloatFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  stack: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  user: userUpdateOneRequiredWithoutTransactionsInput
}

input transactionsUpdateManyMutationInput {
  amount: FloatFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  stack: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input transactionsUpdateManyWithoutUserInput {
  connect: [transactionsWhereUniqueInput!]
  connectOrCreate: [transactionsCreateOrConnectWithoutuserInput!]
  create: [transactionsCreateWithoutUserInput!]
  delete: [transactionsWhereUniqueInput!]
  deleteMany: [transactionsScalarWhereInput!]
  disconnect: [transactionsWhereUniqueInput!]
  set: [transactionsWhereUniqueInput!]
  update: [transactionsUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [transactionsUpdateManyWithWhereWithoutUserInput!]
  upsert: [transactionsUpsertWithWhereUniqueWithoutUserInput!]
}

input transactionsUpdateManyWithWhereWithoutUserInput {
  data: transactionsUpdateManyMutationInput!
  where: transactionsScalarWhereInput!
}

input transactionsUpdateWithoutUserInput {
  amount: FloatFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  stack: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input transactionsUpdateWithWhereUniqueWithoutUserInput {
  data: transactionsUpdateWithoutUserInput!
  where: transactionsWhereUniqueInput!
}

input transactionsUpsertWithWhereUniqueWithoutUserInput {
  create: transactionsCreateWithoutUserInput!
  update: transactionsUpdateWithoutUserInput!
  where: transactionsWhereUniqueInput!
}

input transactionsWhereInput {
  amount: FloatFilter
  AND: [transactionsWhereInput!]
  date: DateTimeFilter
  description: StringFilter
  id: IntFilter
  NOT: [transactionsWhereInput!]
  OR: [transactionsWhereInput!]
  stack: StringFilter
  type: StringFilter
  user: userWhereInput
  userId: IntFilter
}

input transactionsWhereUniqueInput {
  id: Int
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type UploadFile {
  filename: String
  uri: String
}

type user {
  budget: budget!
  email: String!
  id: Int!
  transactions(after: transactionsWhereUniqueInput, before: transactionsWhereUniqueInput, first: Int, last: Int): [transactions!]!
}

input userCreateInput {
  budget: budgetCreateOneWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  image: String
  name: String
  transactions: transactionsCreateManyWithoutUserInput
  updatedAt: DateTime
}

input userCreateOneWithoutBudgetInput {
  connect: userWhereUniqueInput
  connectOrCreate: userCreateOrConnectWithoutbudgetInput
  create: userCreateWithoutBudgetInput
}

input userCreateOneWithoutTransactionsInput {
  connect: userWhereUniqueInput
  connectOrCreate: userCreateOrConnectWithouttransactionsInput
  create: userCreateWithoutTransactionsInput
}

input userCreateOrConnectWithoutbudgetInput {
  create: userCreateWithoutBudgetInput!
  where: userWhereUniqueInput!
}

input userCreateOrConnectWithouttransactionsInput {
  create: userCreateWithoutTransactionsInput!
  where: userWhereUniqueInput!
}

input userCreateWithoutBudgetInput {
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  image: String
  name: String
  transactions: transactionsCreateManyWithoutUserInput
  updatedAt: DateTime
}

input userCreateWithoutTransactionsInput {
  budget: budgetCreateOneWithoutUserInput
  createdAt: DateTime
  email: String!
  emailVerified: DateTime
  image: String
  name: String
  updatedAt: DateTime
}

input userUpdateOneRequiredWithoutBudgetInput {
  connect: userWhereUniqueInput
  connectOrCreate: userCreateOrConnectWithoutbudgetInput
  create: userCreateWithoutBudgetInput
  update: userUpdateWithoutBudgetInput
  upsert: userUpsertWithoutBudgetInput
}

input userUpdateOneRequiredWithoutTransactionsInput {
  connect: userWhereUniqueInput
  connectOrCreate: userCreateOrConnectWithouttransactionsInput
  create: userCreateWithoutTransactionsInput
  update: userUpdateWithoutTransactionsInput
  upsert: userUpsertWithoutTransactionsInput
}

input userUpdateWithoutBudgetInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  transactions: transactionsUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input userUpdateWithoutTransactionsInput {
  budget: budgetUpdateOneRequiredWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input userUpsertWithoutBudgetInput {
  create: userCreateWithoutBudgetInput!
  update: userUpdateWithoutBudgetInput!
}

input userUpsertWithoutTransactionsInput {
  create: userCreateWithoutTransactionsInput!
  update: userUpdateWithoutTransactionsInput!
}

input userWhereInput {
  AND: [userWhereInput!]
  budget: budgetWhereInput
  createdAt: DateTimeFilter
  email: StringFilter
  emailVerified: DateTimeNullableFilter
  id: IntFilter
  image: StringNullableFilter
  name: StringNullableFilter
  NOT: [userWhereInput!]
  OR: [userWhereInput!]
  transactions: TransactionsListRelationFilter
  updatedAt: DateTimeFilter
}

input userWhereUniqueInput {
  email: String
  id: Int
}
