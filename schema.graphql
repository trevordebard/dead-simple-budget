### This file was generated by Nexus Schema
### Do not make changes to this file directly


type budget {
  id: Int!
  stacks(after: stacksWhereUniqueInput, before: stacksWhereUniqueInput, first: Int, last: Int): [stacks!]!
  toBeBudgeted: Float
  total: Float
  userId: Int!
}

input budgetCreateInput {
  stacks: stacksCreateManyWithoutBudgetInput
  toBeBudgeted: Float
  total: Float
  user: userCreateOneWithoutBudgetInput!
}

input budgetCreateOneWithoutStacksInput {
  connect: budgetWhereUniqueInput
  create: budgetCreateWithoutStacksInput
}

input budgetCreateOneWithoutUserInput {
  connect: budgetWhereUniqueInput
  create: budgetCreateWithoutUserInput
}

input budgetCreateWithoutStacksInput {
  toBeBudgeted: Float
  total: Float
  user: userCreateOneWithoutBudgetInput!
}

input budgetCreateWithoutUserInput {
  stacks: stacksCreateManyWithoutBudgetInput
  toBeBudgeted: Float
  total: Float
}

input BudgetId_label_idxCompoundUniqueInput {
  budgetId: Int!
  label: String!
}

input budgetUpdateInput {
  stacks: stacksUpdateManyWithoutBudgetInput
  toBeBudgeted: NullableFloatFieldUpdateOperationsInput
  total: NullableFloatFieldUpdateOperationsInput
  user: userUpdateOneRequiredWithoutBudgetInput
}

input budgetUpdateOneRequiredWithoutStacksInput {
  connect: budgetWhereUniqueInput
  create: budgetCreateWithoutStacksInput
  update: budgetUpdateWithoutStacksDataInput
  upsert: budgetUpsertWithoutStacksInput
}

input budgetUpdateOneRequiredWithoutUserInput {
  connect: budgetWhereUniqueInput
  create: budgetCreateWithoutUserInput
  update: budgetUpdateWithoutUserDataInput
  upsert: budgetUpsertWithoutUserInput
}

input budgetUpdateWithoutStacksDataInput {
  toBeBudgeted: NullableFloatFieldUpdateOperationsInput
  total: NullableFloatFieldUpdateOperationsInput
  user: userUpdateOneRequiredWithoutBudgetInput
}

input budgetUpdateWithoutUserDataInput {
  stacks: stacksUpdateManyWithoutBudgetInput
  toBeBudgeted: NullableFloatFieldUpdateOperationsInput
  total: NullableFloatFieldUpdateOperationsInput
}

input budgetUpsertWithoutStacksInput {
  create: budgetCreateWithoutStacksInput!
  update: budgetUpdateWithoutStacksDataInput!
}

input budgetUpsertWithoutUserInput {
  create: budgetCreateWithoutUserInput!
  update: budgetUpdateWithoutUserDataInput!
}

input budgetWhereInput {
  AND: [budgetWhereInput]
  id: IntFilter
  NOT: [budgetWhereInput]
  OR: [budgetWhereInput]
  stacks: StacksListRelationFilter
  toBeBudgeted: FloatNullableFilter
  total: FloatNullableFilter
  user: userWhereInput
  userId: IntFilter
}

input budgetWhereUniqueInput {
  id: Int
}

scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime]
}

input FloatFieldUpdateOperationsInput {
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

type Mutation {
  createOnebudget(data: budgetCreateInput!): budget!
  createOnestacks(data: stacksCreateInput!): stacks!
  createOnetransactions(data: transactionsCreateInput!): transactions!
  createOneuser(data: userCreateInput!): user!
  updateOnebudget(data: budgetUpdateInput!, where: budgetWhereUniqueInput!): budget
  updateOnestacks(data: stacksUpdateInput!, where: stacksWhereUniqueInput!): stacks
  updateOnetransactions(data: transactionsUpdateInput!, where: transactionsWhereUniqueInput!): transactions
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableFloatFieldUpdateOperationsInput {
  set: Float
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  budget(where: budgetWhereUniqueInput!): budget
  budgets(after: budgetWhereUniqueInput, before: budgetWhereUniqueInput, first: Int, last: Int, where: QueryBudgetsWhereInput): [budget!]!
  stacks(after: stacksWhereUniqueInput, before: stacksWhereUniqueInput, first: Int, last: Int): [stacks!]!
  transactions(after: transactionsWhereUniqueInput, before: transactionsWhereUniqueInput, first: Int, last: Int, where: QueryTransactionsWhereInput): [transactions!]!
  user(where: userWhereUniqueInput!): user
}

input QueryBudgetsWhereInput {
  user: userWhereInput
  userId: IntFilter
}

input QueryTransactionsWhereInput {
  user: userWhereInput
  userId: IntFilter
}

type stacks {
  amount: Float!
  budgetId: Int!
  created_at: DateTime!
  id: Int!
  label: String!
}

input stacksCreateInput {
  amount: Float
  budget: budgetCreateOneWithoutStacksInput!
  created_at: DateTime
  label: String!
}

input stacksCreateManyWithoutBudgetInput {
  connect: [stacksWhereUniqueInput]
  create: [stacksCreateWithoutBudgetInput]
}

input stacksCreateWithoutBudgetInput {
  amount: Float
  created_at: DateTime
  label: String!
}

input StacksListRelationFilter {
  every: stacksWhereInput
  none: stacksWhereInput
  some: stacksWhereInput
}

input stacksScalarWhereInput {
  amount: FloatFilter
  AND: [stacksScalarWhereInput]
  budgetId: IntFilter
  created_at: DateTimeFilter
  id: IntFilter
  label: StringFilter
  NOT: [stacksScalarWhereInput]
  OR: [stacksScalarWhereInput]
}

input stacksUpdateInput {
  amount: FloatFieldUpdateOperationsInput
  budget: budgetUpdateOneRequiredWithoutStacksInput
  created_at: DateTimeFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
}

input stacksUpdateManyDataInput {
  amount: FloatFieldUpdateOperationsInput
  created_at: DateTimeFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
}

input stacksUpdateManyWithoutBudgetInput {
  connect: [stacksWhereUniqueInput]
  create: [stacksCreateWithoutBudgetInput]
  delete: [stacksWhereUniqueInput]
  deleteMany: [stacksScalarWhereInput]
  disconnect: [stacksWhereUniqueInput]
  set: [stacksWhereUniqueInput]
  update: [stacksUpdateWithWhereUniqueWithoutBudgetInput]
  updateMany: [stacksUpdateManyWithWhereNestedInput]
  upsert: [stacksUpsertWithWhereUniqueWithoutBudgetInput]
}

input stacksUpdateManyWithWhereNestedInput {
  data: stacksUpdateManyDataInput!
  where: stacksScalarWhereInput!
}

input stacksUpdateWithoutBudgetDataInput {
  amount: FloatFieldUpdateOperationsInput
  created_at: DateTimeFieldUpdateOperationsInput
  label: StringFieldUpdateOperationsInput
}

input stacksUpdateWithWhereUniqueWithoutBudgetInput {
  data: stacksUpdateWithoutBudgetDataInput!
  where: stacksWhereUniqueInput!
}

input stacksUpsertWithWhereUniqueWithoutBudgetInput {
  create: stacksCreateWithoutBudgetInput!
  update: stacksUpdateWithoutBudgetDataInput!
  where: stacksWhereUniqueInput!
}

input stacksWhereInput {
  amount: FloatFilter
  AND: [stacksWhereInput]
  budget: budgetWhereInput
  budgetId: IntFilter
  created_at: DateTimeFilter
  id: IntFilter
  label: StringFilter
  NOT: [stacksWhereInput]
  OR: [stacksWhereInput]
}

input stacksWhereUniqueInput {
  budgetId_label_idx: BudgetId_label_idxCompoundUniqueInput
  id: Int
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String]
  startsWith: String
}

type transactions {
  amount: Float!
  date: DateTime!
  description: String!
  id: Int!
  stack: String!
  type: String!
  userId: Int!
}

input transactionsCreateInput {
  amount: Float!
  date: DateTime!
  description: String!
  stack: String!
  type: String!
  user: userCreateOneWithoutTransactionsInput!
}

input transactionsCreateManyWithoutUserInput {
  connect: [transactionsWhereUniqueInput]
  create: [transactionsCreateWithoutUserInput]
}

input transactionsCreateWithoutUserInput {
  amount: Float!
  date: DateTime!
  description: String!
  stack: String!
  type: String!
}

input TransactionsListRelationFilter {
  every: transactionsWhereInput
  none: transactionsWhereInput
  some: transactionsWhereInput
}

input transactionsScalarWhereInput {
  amount: FloatFilter
  AND: [transactionsScalarWhereInput]
  date: DateTimeFilter
  description: StringFilter
  id: IntFilter
  NOT: [transactionsScalarWhereInput]
  OR: [transactionsScalarWhereInput]
  stack: StringFilter
  type: StringFilter
  userId: IntFilter
}

input transactionsUpdateInput {
  amount: FloatFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  stack: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  user: userUpdateOneRequiredWithoutTransactionsInput
}

input transactionsUpdateManyDataInput {
  amount: FloatFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  stack: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input transactionsUpdateManyWithoutUserInput {
  connect: [transactionsWhereUniqueInput]
  create: [transactionsCreateWithoutUserInput]
  delete: [transactionsWhereUniqueInput]
  deleteMany: [transactionsScalarWhereInput]
  disconnect: [transactionsWhereUniqueInput]
  set: [transactionsWhereUniqueInput]
  update: [transactionsUpdateWithWhereUniqueWithoutUserInput]
  updateMany: [transactionsUpdateManyWithWhereNestedInput]
  upsert: [transactionsUpsertWithWhereUniqueWithoutUserInput]
}

input transactionsUpdateManyWithWhereNestedInput {
  data: transactionsUpdateManyDataInput!
  where: transactionsScalarWhereInput!
}

input transactionsUpdateWithoutUserDataInput {
  amount: FloatFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  stack: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input transactionsUpdateWithWhereUniqueWithoutUserInput {
  data: transactionsUpdateWithoutUserDataInput!
  where: transactionsWhereUniqueInput!
}

input transactionsUpsertWithWhereUniqueWithoutUserInput {
  create: transactionsCreateWithoutUserInput!
  update: transactionsUpdateWithoutUserDataInput!
  where: transactionsWhereUniqueInput!
}

input transactionsWhereInput {
  amount: FloatFilter
  AND: [transactionsWhereInput]
  date: DateTimeFilter
  description: StringFilter
  id: IntFilter
  NOT: [transactionsWhereInput]
  OR: [transactionsWhereInput]
  stack: StringFilter
  type: StringFilter
  user: userWhereInput
  userId: IntFilter
}

input transactionsWhereUniqueInput {
  id: Int
}

type user {
  budget: budget!
  email: String
  id: Int!
  transactions(after: transactionsWhereUniqueInput, before: transactionsWhereUniqueInput, first: Int, last: Int): [transactions!]!
}

input userCreateInput {
  budget: budgetCreateOneWithoutUserInput
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  image: String
  name: String
  transactions: transactionsCreateManyWithoutUserInput
  updatedAt: DateTime
}

input userCreateOneWithoutBudgetInput {
  connect: userWhereUniqueInput
  create: userCreateWithoutBudgetInput
}

input userCreateOneWithoutTransactionsInput {
  connect: userWhereUniqueInput
  create: userCreateWithoutTransactionsInput
}

input userCreateWithoutBudgetInput {
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  image: String
  name: String
  transactions: transactionsCreateManyWithoutUserInput
  updatedAt: DateTime
}

input userCreateWithoutTransactionsInput {
  budget: budgetCreateOneWithoutUserInput
  createdAt: DateTime
  email: String
  emailVerified: DateTime
  image: String
  name: String
  updatedAt: DateTime
}

input userUpdateOneRequiredWithoutBudgetInput {
  connect: userWhereUniqueInput
  create: userCreateWithoutBudgetInput
  update: userUpdateWithoutBudgetDataInput
  upsert: userUpsertWithoutBudgetInput
}

input userUpdateOneRequiredWithoutTransactionsInput {
  connect: userWhereUniqueInput
  create: userCreateWithoutTransactionsInput
  update: userUpdateWithoutTransactionsDataInput
  upsert: userUpsertWithoutTransactionsInput
}

input userUpdateWithoutBudgetDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  transactions: transactionsUpdateManyWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input userUpdateWithoutTransactionsDataInput {
  budget: budgetUpdateOneRequiredWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input userUpsertWithoutBudgetInput {
  create: userCreateWithoutBudgetInput!
  update: userUpdateWithoutBudgetDataInput!
}

input userUpsertWithoutTransactionsInput {
  create: userCreateWithoutTransactionsInput!
  update: userUpdateWithoutTransactionsDataInput!
}

input userWhereInput {
  AND: [userWhereInput]
  budget: budgetWhereInput
  createdAt: DateTimeFilter
  email: StringNullableFilter
  emailVerified: DateTimeNullableFilter
  id: IntFilter
  image: StringNullableFilter
  name: StringNullableFilter
  NOT: [userWhereInput]
  OR: [userWhereInput]
  transactions: TransactionsListRelationFilter
  updatedAt: DateTimeFilter
}

input userWhereUniqueInput {
  email: String
  id: Int
}
